;+; NAME:;       ONESURF;; PURPOSE:;       This function returns a 24-bit image of a surface with various;    combinations of colour, shading and grids.  The colour coding can;    tied to the surface height or to an independent array.  A grid can;    be overlaid on the surface or used to mask a coloured or shaded plot;    so as to produce a coloured and/or shaded grid.  Light shading can;    be applied to both the coloured and gridded surface, or just the;    coloured surface, leaving the grid unshaded.;;        The plotting is done on the current device, which can be any;    device which supports the TVRD command: eg screen windows, pixmaps,;    or the z-buffer.;;        The light shading parameters are determined by previous calls to ;    SET_SHADING.  The viewing position and 3d-2d scaling are handled by;    the usual graphics keywords - see the documentation for SURFACE and;    SHADE_SURF in the IDL user's guide.;;        The image returned by ONESURF is a pixel-interleaved 24-bit ;     image of type bytarr(3, xsize, ysize), where xsize and ysize ;     are the dimensions of the current graphics window.; ;; CATEGORY:;       Graphics, Surface Plotting;; CALLING SEQUENCE:;       result = ONESURF(SURFDATA);; INPUTS:;       SURFDATA:  a two-dimensional array of type byte containing the;                  data to be plotted.;; KEYWORD PARAMETERS:;;       COLOUR:  Set this keyword to include colour coding in the plot;                The default is no colour-coding.;;       COLDATA: A variable or array of type byte containing the colour ;                data to be used when plotting a colour plot.;                If COLDATA is a scalar then it is assumed to be an index to;                a colour in COLMAP which is used to give a single colour to;                whole surface.;                If COLDATA is a vector of at least three elements its first;                three elements are treated as a rgb colour triple and used;                to give a single colour to the whole surface.;                If COLDATA is two-dimensional it is treated as an array of;                colour indices of COLMAP and used to give each data point;                it's own colour.  If COLDATA has different dimensions to;                SURFDATA, CONGRID is used to stretch or squeeze a copy of;                COLDATA to fit.;                If COLOUR is set but COLDATA is undefined or does not satisfy;                any of the above conditions, a BYTSCL'ed version of SURFDATA is;                used to produce a plot coloured according to height.;;       COLMAP:  The colour map to use for plotting of the colour data.;                If a number is given the corresponding inbuilt IDL colour;                map is used.  Otherwise COLMAP should be an array of three;                byte vectors [red, green, blue] such as those returned by;                the TVLCT, /get procedure.  If COLMAP is not set, the;                current colour map is used.  Note that ONESURF maintains;                the current colour map even if a different map is specified;                for the plot.;;       SHADE:   Set this keyword to perform light shading.;                    SHADE = 0: no shading;                    SHADE = 1: shade everything;                    SHADE = 2: don't shade the grid;                The default is no shading;                ;       GRID:    Set this keyword to apply grids to the surface;                    GRID = 0: no grid;                    GRID = 1: overlay a grid on the surface;                    GRID = 2: use the grid as a mask;                The default is no grid;;       CGRID:   The colour to use for overlaid grids.  If CGRID is a number;                it is treated as an index in the colour table given by COLMAP.;                If CGRID is an three-element vector of bytes it is treated;                as the rgb values for a colour.  If it is anything else or;                undefined the grid is plotted white.;;       _EXTRA:  Used to pass extra plot parameters to both SHADE_SURF and;                SURFACE.  _EXTRA provides a convenient way of passing;                common parameters such as viewing angle and plot position.;                Note that only keywords valid for both SHADE_SURF and SURFACE;                can be used.;                If EXTRA_SHADE is set, _EXTRA is ignored for the shaded plots,;                similarly with EXTRA_SURF and surface plots.;                Some keywords (eg, SHADES, COLOR, NODATA, NOERASE) will;                interfere with the plotting done by ONESURF and lead to;                unpredictable results.;                _EXTRA is itself passed to SHADE_SURF and SURFACE using;                the _EXTRA keyword, so keywords which expect a data value;                to be changed (eg [XYZ]TICK_GET) will not work.;                Useable keywords are: AX, AZ, MAX_VALUE, MIN_VALUE, SAVE,;                [XY]TYPE, CHARSIZE, CHARTHICK, CLIP, DATA, DEVICE, FONT,;                NOCLIP, NORMAL, POSITION, SUBTITLE, T3D, THICK, TICKLEN,;                TITLE, [XYZ]CHARSIZE, [XYZ]GRIDSTYLE, [XYZ]MARGIN, [XYZ]MINOR;                [XYZ]RANGE, [XYZ]STYLE, [XYZ]THICK, [XYZ]TICKFORMAT,;                [XYZ]TICKLEN, [XYZ]TICKNAME, [XYZ]TICKS, [XYZ]TICKV,;                [XYZ]TITLE, ZVALUE.;;       EXTRA_SHADE:  Used to pass extra plot parameters to the SHADE_SURF ;                     procedure only.  EXTRA_SHADE is passed to SHADE_SURF;                     using the _EXTRA keyword so keywords such as IMAGE;                     which expect a variable to be altered will not work.;                     As with _EXTRA, setting the SHADES keyword can lead;                     to unpredictable results.  EXTRA_SURF should be an;                     anonymous structure.;;       EXTRA_SURF:  Used to pass extra plot parameters to the SURFACE;                    procedure only.  Restrictions are as for _EXTRA and;                    EXTRA_SHADE.  If EXTRA_SHADE is set, but EXTRA_SURF;                    is not, EXTRA_SURF is made equal to _EXTRA, and vice;                    versa.;                    ;;; COMMON BLOCKS:;       None.;; SIDE EFFECTS:;       None.;; RESTRICTIONS:;       None.;; EXAMPLE:;       Create an image of a surface coloured according to height using;   the current colour map, with light shading and no grid:;           image = onesurf(surfdata, /colour, /shade);;       Create a shaded green grid on a shaded surface:;           image = onesurf(surfdata, /shade, /grid, cgrid=[0,255,0]);;       Create a shaded view of a surface, coloured according to a second;   array using colour map 25, overlaid with a grey, unshaded grid:;           image = onesurf(surfdata, /colour, colmap=25, coldata=second_array, $;                             shade=2, /grid, cgrid=[127,127,127]);; MODIFICATION HISTORY:;       Part of Struan's Surface Tutorial: ;            http://www.sljus.lu.se/stm/IDL/Surf_Tips/;       Written by:	Struan Gray, Sljusfysik, Lunds Universitet, 970305.;       970313 SMG - added _extra, extra_surf and extra_shade keywords;                    for better control of graphics keywords.;-function onesurf, surfdata,                $ ; array with height data                  colour=colour,           $ ; colour flag: 0: no, 1: yes                  coldata=coldata,         $ ; byte array with colour data                  colmap=colmap,           $ ; colourmap: value or rgb vectors                  shade=shade,             $ ; shade flag: 0:none, 1: all, 2: not grid                  grid=grid,               $ ; gridflag: 0:none, 1:overlay, 2:mask                  cgrid=cgrid,             $ ; grid colour: value or rgb triple                  extra_shade=extra_shade, $ ; extra parameters for shaded plots                  extra_surf=extra_surf,   $ ; extra parameters for surface plots                  _extra=extra               ; common extra plot parameters   ; check plot flags to find which plot methods to use, set defaults if needed   if not(keyword_set(colour)) then colour=0   if not(keyword_set(shade)) then shade=0   if not(keyword_set(grid)) then grid=0      ; construct the extra parameter blocks   if (n_elements(extra) ne 0) then begin     if (n_elements(extra_shade) eq 0) then extra_shade = extra     if (n_elements(extra_surf) eq 0) then extra_surf = extra   endif  ; find the size of the plot window, save the current colours, create blank image    xwin = !d.x_size   ywin = !d.y_size   tvlct, red, grn, blu, /get   image = bytarr(3,xwin, ywin)            ; check that surfdata is two-dimensional   surf_size = size(surfdata)   if surf_size(0) ne 2 then begin     print, "ONESURF: Surface Data is not two dimensional"     return, image   endif; if colour map specified, load and use it, otherwise use current map        if n_elements(colmap) ne 0 then begin              ; load colour map if given      cmap_size = size(colmap)      case cmap_size(0) of        0: loadct, colmap        2: tvlct, colmap(0,*), colmap(1,*), colmap(2,*)        else:      endcase    end; find the background index and rgb colour triple and set up the grid colour             tvlct, tred, tgrn, tblu, /get    bgidx = !p.background    if n_elements(bgidx) eq 0 then bgidx = 0    if (shade ne 0) then bgcol = [0b,0b,0b] $      else bgcol = [tred(bgidx), tgrn(bgidx), tblu(bgidx)]    case n_elements(cgrid) of      1: cgrid = [tred(cgrid),tgrn(cgrid),tblu(cgrid)]      3:      else: cgrid = [255b,255b,255b]    endcase      ; if coloured surface asked for, plot it and create 24-bit version  if colour then begin           ; check and/or create the array of colour indices    col_size = size(coldata)    case col_size(0) of      0: if col_size(1) ne 0 then begin        col_data = bytarr(surf_size(1), surf_size(2), /nozero)        col_data(*,*) = coldata(0)        endif else col_data = bytscl(surfdata)      1: if col_size(1) ge 3 then begin        col_data = bytarr(surf_size(1), surf_size(2), /nozero)        col_data(*,*) = 1b        tred(1) = coldata(0)        tgrn(1) = coldata(1)        tblu(1) = coldata(2)        tvlct, tred, tgrn, tblu        endif else col_data = bytscl(surfdata)      2: if (col_size(1) ne surf_size(1)) or (col_size(2) ne surf_size(2)) then  $           col_data = congrid(coldata, surf_size(1), surf_size(2), /minus_one) else $           col_data = coldata      else: col_data = bytscl(surfdata)    endcase    tred = 0    tgrn = 0    tblu = 0    shade_surf, surfdata, shades=col_data, _extra=extra_shade    image = tvrd_24()      endif else if shade eq 1 then $    for i=0,2 do image(i,*,*) = 255b  $         ; fill with white    else for i=0,2 do image(i,*,*) = bgidx; if any sort of grid asked for, plot it  if grid ne 0 then begin    tvlct, indgen(256), indgen(256), indgen(256)    surface, surfdata, _extra=extra_surf    gridpic = tvrd()    if shade ne 2 then surfgrid, image, gridpic, $       gridcode=grid, gridcol=cgrid, bgidx=bgidx, bgcol=bgcol  endif; if shading asked for, create shaded surface  if shade ne 0 then begin        tvlct, indgen(256), indgen(256), indgen(256)    shade_surf, surfdata, _extra=extra_shade    shade_array = tvrd()        if (colour ne 0) or (grid ne 0) then begin      image = long(image)      for i=0,2 do image(i,*,*) = image(i,*,*)*shade_array      image = byte(image/255l)      if (shade eq 2) and (grid ne 0) then surfgrid, image, gridpic, $         gridcode=grid, gridcol=cgrid, bgidx=bgidx, bgcol=bgcol    endif else for i=0,2 do image(i,*,*) = shade_array  endif; restore original colour table and return  tvlct, red, grn, blu  return, imageend ; function onesurf